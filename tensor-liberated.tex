%% Style copied from https://github.com/omelkonian/presentations/tree/master/%5B2019.08.20%5D%20BitML%20(SRC%20Presentation%20%40%20ICFP))

%% \documentclass[aspectratio=43]{beamer}
\documentclass[aspectratio=169]{beamer}

%% \usetheme[
%%   % block=fill,
%%   %% background=light,
%%   % titleformat=smallcaps,
%%   % progressbar=frametitle,
%%   % numbering=none,
%% ]{metropolis}%Warsaw,Madrid

%% \setbeamercolor{background canvas}{bg=white} %% otherwise ``light''

\usecolortheme{crane}%whale,beaver
\usefonttheme{serif}
\useinnertheme[shadow]{rounded}
% \useoutertheme{default}
\useoutertheme{shadow}
\useoutertheme{infolines}
% Suppress navigation arrows
\setbeamertemplate{navigation symbols}{}

\setbeamersize{text margin left=.5cm,text margin right=.5cm}

\usepackage{catchfilebetweentags}
\usepackage[useregional]{datetime2}

\RequirePackage{agda, tikz-cd, newunicodechar, amssymb, stmaryrd, unicode-math, setspace, comment, listings, anyfontsize}

\input{macros}
\input{commands}
\input{unicode}
\input{Blank}

%% Arrow labels are too small by default
\tikzcdset{every label/.append style = {font = \normalsize}}
\tikzcdset{every diagram/.append style = {ampersand replacement=\&}}

\tikzcdset{   row sep/normal=17ex}
\tikzcdset{column sep/normal=8em}

\nc\arD[2]{\arrow[#1, "#2"{description}]}
\nc\arR[1]{\arD{r}{#1} \&}
\nc\arU[1]{\arD{u}{#1}}
\nc\arUR[2]{\arD{u}{#1} \arD{r}{#2} \&}

%% \usepackage{libertine}  %% [tt=false]

%% \setmathfont{XITSMath-Regular.otf}

%----------------------------------------------------------------------------

\title[Can Tensor Programming Be Liberated ...?]{Can Tensor Programming Be Liberated\\ from the Fortran Data Paradigm?}
% \subtitle{...}
\author{Conal Elliott}
\date{October 2021}

\begin{document}

\maketitle

\begin{frame}{``This is the Unix philosophy:}
\begin{itemize}\itemsep4ex
\item Write programs that do one thing and do it well.
\item Write programs to work together.
\item Write programs to handle text streams, because that is a universal interface.''
\end{itemize}
\vspace{2ex}
\begin{flushright}
-- Doug McIlroy \hspace{0.5in}{\ }
\end{flushright}
\end{frame}

\begin{frame}{How Unix defeated its own philosophy}
%% \pause
\begin{itemize}\itemsep4ex
\item \textcolor{blue}{Write programs that do one thing and do it well.}
\item Write programs to work together.
\item \textcolor{red}{Write programs to handle text streams, because that is a universal interface.}
\end{itemize}

\pause
\vspace{5.5ex}
\emph{Every Unix program contains a parser (from text) and unparser (to text).}
\end{frame}

\begin{frame}{Likewise,}
\begin{center}
\emph{Every array program contains a parser (from arrays) and unparser (to arrays).}
\end{center}
\end{frame}

\begin{frame}[fragile]{An efficient array program (CUDA C)}
\begin{minipage}[c]{0.7\textwidth}
\fontsize{5pt}{6pt}
\begin{verbatim}
__global__ void prescan(float *g_odata, float *g_idata, int n) {
    extern __shared__ float temp[];  // allocated on invocation
    int thid = threadIdx.x;
    int offset = 1;
    // load input into shared memory
    temp[2*thid] = g_idata[2*thid];
    temp[2*thid+1] = g_idata[2*thid+1];
    // build sum in place up the tree
    for (int d = n>>1; d > 0; d >>= 1) {
        __syncthreads();
        if (thid < d) {
            int ai = offset*(2*thid+1)-1;
            int bi = offset*(2*thid+2)-1;
            temp[bi] += temp[ai]; }
        offset *= 2; }
    // clear the last element
    if (thid == 0) { temp[n - 1] = 0; }
    // traverse down tree & build scan
    for (int d = 1; d < n; d *= 2) {
        offset >>= 1;
        __syncthreads();
        if (thid < d) {
            int ai = offset*(2*thid+1)-1;
            int bi = offset*(2*thid+2)-1;
            float t = temp[ai];
            temp[ai] = temp[bi];
            temp[bi] += t; } }
    __syncthreads();
    // write results to device memory
    g_odata[2*thid] = temp[2*thid];
    g_odata[2*thid+1] = temp[2*thid+1]; }
\end{verbatim}
\end{minipage}
\hspace{-1in}
\begin{minipage}[c]{0.25\textwidth}
\begin{figure}
\wpicture{2in}{beaker}
\\
\hspace{0.75in}\emph{WAT}
\end{figure}
\end{minipage}

\scriptsize
\vspace{-3ex}
\hspace{2.5in}
\href{http://http.developer.nvidia.com/GPUGems3/gpugems3_ch39.html}{Source: Harris, Sengupta, and Owens in \emph{GPU Gems 3}, Chapter 39}
\end{frame}

\begin{frame}[fragile]{In NESL}
\vspace{6ex}
\begin{quote}
\begin{verbatim}
function scan(a) =
  if #a == 1 then [0]
  else
    let es = even_elts(a);
        os = odd_elts(a);
        ss = scan({e+o: e in es; o in os})
    in interleave(ss,{s+e: s in ss; e in es})
\end{verbatim}
\end{quote}
\vspace{1ex}
{\scriptsize
\hspace{2.5in}\href{http://citeseerx.ist.psu.edu/viewdoc/summary?doi=10.1.1.53.5739}{Source: Guy Blelloch in \emph{Programming parallel algorithms, 1990}}}

\pause\vspace{2ex}
Still, why does it work?
\end{frame}

\begin{frame}{Realization}
\begin{center}
\Large
\emph{It's not naturally an array algorithm.}
\end{center}
\end{frame}

\rnc\SourceModule{Code}

\begin{frame}{First guess}
\source{Guess1}
\end{frame}

\nc\scanT{\text{scanᵀ}}
\nc\scanA{\text{scanᴬ}}
\nc\parse{\text{parse}}
\nc\id{\text{id}}
%% \nc\T[2]{\text{Tree}_{#1}\, #2}
\nc\BT[2]{2^{\uparrow #1}\, #2}
\nc\Arr[2]{\text{Arr}_{#1}\, #2}

\begin{frame}{Correctness}

\[\begin{tikzcd}
  \BT n a \arR{\scanT} \BT n a \\
  \Arr{2^n}a \arUR{\parse}{\scanA} \Arr{2^n}a \arU{\parse}
\end{tikzcd}\]

\end{frame}

\end{document}
